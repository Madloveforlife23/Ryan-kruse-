#! /bin/sh
### BEGIN INIT INFO
# Provides:          cgproxy
# Required-Start:    cgmanager
# Required-Stop:     
# Default-Start:    2 3 4 5
# Default-Stop:     0 1 6
# Short-Description: Cgroup manager daemon
# Description:
#  The cgroup manager accepts cgroup administration requests
#  over dbus, honoring privilege by root users in mapped user
#  namespaces over the non-root mapped uids.  This allows safe
#  nesting of lxc containers by unprivileged users.
### END INIT INFO

. /lib/lsb/init-functions

DAEMON=/sbin/cgproxy
NAME=cgproxy
DESC="cgroup management proxy daemon"

BASEOPTS="--daemon"

test -x $DAEMON || exit 0

PIDFILE=/run/$NAME.pid

if [ -f /etc/default/cgmanager ]; then
	# get cgmanager_opts if specified
	. /etc/default/cgmanager
fi

running_pid()
{
    # Check if a given process pid's cmdline matches a given name
    pid=$1
    name=$2
    [ -z "$pid" ] && return 1
    [ ! -d /proc/$pid ] &&  return 1
    cmd=`cat /proc/$pid/cmdline | tr "\000" "\n"|head -n 1 |cut -d : -f 1`
    # Is this the expected child?
    [ "$cmd" != "$name" ] &&  return 1
    return 0
}

running()
{
  [ ! -f "$PIDFILE" ] && return 1
  pid=`cat $PIDFILE`
  running_pid $pid $DAEMON || return 1
  return 0
}

stop()
{
	start-stop-daemon --stop --retry 5 --quiet --pidfile $PIDFILE --exec $DAEMON
	return 0
}

start()
{
	rm -f $PIDFILE
	if [ -e /proc/self/ns/pid ] && [ "$NESTED" != "yes" ]; then
		log_daemon_msg "Kernel is new enough and not nested, no proxy is needed"
		log_end_msg 0
		exit 0
	fi
	start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- $BASEOPTS $cgmanager_opts
	sleep 1
}

case "$1" in
    restart|force-reload)
	log_daemon_msg "Restarting $DESC" "$NAME"
	stop
	# not sure this makes sense - should we just stop it and count on the
	# cgmanager starting the cgproxy?
	start
	if running; then
		log_end_msg 0
	else
		log_end_msg 1
	fi
	;;
    start)
	log_daemon_msg "Starting $DESC" "$NAME"
	if running; then
		log_progress_msg "already running"
		log_end_msg 0
		exit 0
	fi
	start
	if running; then
		log_end_msg 0
	else
		log_end_msg 1
	fi
	;;
  stop)
	log_daemon_msg "Stopping $DESC" "$NAME"
	if ! running ; then
		log_progress_msg "not running"
		log_end_msg 0
		exit 0
	fi
	stop
	log_end_msg 0
	;;
  status)
	log_daemon_msg "Checking status of $DESC" "$NAME"
	if running ; then
		log_progress_msg "running"
            log_end_msg 0
        else
            log_progress_msg "not running"
            log_end_msg 1
            if [ -f "$PIDFILE" ] ; then
                exit 1
            else
                exit 3
            fi
        fi
	;;
  *)
	echo "Usage: $0 {start|stop|restart|force-reload}" >&2
	exit 3
	;;
esac

:
